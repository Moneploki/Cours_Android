package com.example.testcours.ui

import BluetoothLEManager
import Device
import android.Manifest
import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothGatt
import android.bluetooth.BluetoothManager
import android.bluetooth.le.*
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.location.LocationManager
import android.os.Build
import android.os.Bundle
import android.os.Handler
import android.provider.Settings
import android.view.View
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import com.afollestad.recyclical.datasource.emptyDataSourceTyped
import com.afollestad.recyclical.setup
import com.afollestad.recyclical.withItem
import com.example.testcours.R
import com.example.testcours.data.DeviceViewHolder
import kotlinx.android.synthetic.main.activity_b_l_e_.*

class BLE_Activity : AppCompatActivity() {
    // REQUEST Code de gestion
    companion object {
        fun getStartIntent(context: Context): Intent {
            return Intent(context, BLE_Activity::class.java)
        }

        const val PERMISSION_REQUEST_LOCATION = 9999
        const val REQUEST_ENABLE_BLE = 9997
    }

    // Gestion du Bluetooth
// L'Adapter permettant de se connecter
    private var bluetoothAdapter: BluetoothAdapter? = null

    // La connexion actuellement Ã©tablie
    private var currentBluetoothGatt: BluetoothGatt? = null

    // Â« Interface systÃ¨me nous permettant de scanner Â»
    private var bluetoothLeScanner: BluetoothLeScanner? = null

    /**
     * Gestion du SCAN, recherche des device BLE Ã  proximitÃ©
     */

// Parametrage du scan BLE
    private val scanSettings =
        ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build()

    // On ne retourne que les Â« Devices Â» proposant le bon UUID
    private var scanFilters: List<ScanFilter> = arrayListOf(
//        ScanFilter.Builder().setServiceUuid(ParcelUuid(BluetoothLEManager.DEVICE_UUID)).build()
    )

    // Variable de fonctionnement
    private var mScanning = false
    private val handler = Handler()

    // Adapter
    private val bleDevicesFoundList = emptyDataSourceTyped<Device>()


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_b_l_e_)
        setUiMode(false)

        Recycler_BLE.setup {
            withDataSource(bleDevicesFoundList)
            withItem<Device, DeviceViewHolder>(R.layout.device_list) {
                onBind(::DeviceViewHolder) { _, item ->
                    name.text = item.name.takeIf { !it.isNullOrEmpty() } ?: run { item.mac }
                }
                onClick {
                    Toast.makeText(
                        this@BLE_Activity,
                        getString(R.string.trying_connection_to, item.name),
                        Toast.LENGTH_SHORT
                    ).show()
                    BluetoothLEManager.currentDevice = item.device
                    connectToCurrentDevice()
                }
            }
        }

        startScan.setOnClickListener {
            askForPermission()
            if (hasPermission()) {
                setupBLE()
            }

        }
    }

    /**
     * GÃ¨re l'action aprÃ¨s la demande de permission.
     * 2 cas possibles :
     * - RÃ©ussite ðŸŽ‰.
     * - Ã‰chec (refus utilisateur).
     */
    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        if (requestCode == PERMISSION_REQUEST_LOCATION && grantResults.size == 1) {
            if (grantResults[0] == PackageManager.PERMISSION_GRANTED && locationServiceEnabled()) {
                // Permission OK => Lancer SCAN
                setupBLE()
            } else if (!locationServiceEnabled()) {
                // Inviter Ã  activer la localisation
                startActivity(Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS))
            } else {
                // Permission KO => GÃ©rer le cas.
                // Vous devez ici modifier le code pour gÃ©rer le cas d'erreur (permission refusÃ©)
                // Avec par exemple une Dialog
            }
        }
    }

    /**
     * Permet de vÃ©rifier si l'application possede la permission Â« Localisation Â». OBLIGATOIRE pour scanner en BLE
     */
    private fun hasPermission(): Boolean {
        return ContextCompat.checkSelfPermission(
            this,
            Manifest.permission.ACCESS_FINE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED
    }

    /**
     * Demande de la permission (ou des permissions) Ã  l'utilisateur.
     */
    private fun askForPermission() {
        ActivityCompat.requestPermissions(
            this,
            arrayOf(Manifest.permission.ACCESS_FINE_LOCATION),
            PERMISSION_REQUEST_LOCATION
        )
    }


    private fun locationServiceEnabled(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            // This is new method provided in API 28
            val lm = this.getSystemService(Context.LOCATION_SERVICE) as LocationManager
            lm.isLocationEnabled
        } else {
            // This is Deprecated in API 28
            val mode = Settings.Secure.getInt(
                this.contentResolver,
                Settings.Secure.LOCATION_MODE,
                Settings.Secure.LOCATION_MODE_OFF
            )
            mode != Settings.Secure.LOCATION_MODE_OFF
        }
    }

    /**
     * RÃ©cupÃ©ration de l'adapter Bluetooth & vÃ©rification si celui-ci est actif
     */
    private fun setupBLE() {
        (getSystemService(BLUETOOTH_SERVICE) as BluetoothManager?)?.let { bluetoothManager ->
            bluetoothAdapter = bluetoothManager.adapter
            if (bluetoothAdapter != null && !bluetoothManager.adapter.isEnabled) {
                startActivityForResult(
                    Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE),
                    REQUEST_ENABLE_BLE
                )
            } else {
                scanLeDevice()
            }
        }
    }

    // Le scan va durer 10 secondes seulement, sauf si vous passez une autre valeur comme paramÃ¨tre.
    private fun scanLeDevice(scanPeriod: Long = 30000) {
        if (!mScanning) {
            bluetoothLeScanner = bluetoothAdapter?.bluetoothLeScanner

            // On vide la liste qui contient les devices actuellement trouvÃ©s
            bleDevicesFoundList.clear()

            mScanning = true

            // On lance une tache qui durera Â« scanPeriod Â» Ã  savoir donc de base
            // 10 secondes
            handler.postDelayed({
                mScanning = false
                bluetoothLeScanner?.stopScan(leScanCallback)
                Toast.makeText(this, getString(R.string.scan_ended), Toast.LENGTH_SHORT).show()
            }, scanPeriod)

            // On lance le scan
            bluetoothLeScanner?.startScan(scanFilters, scanSettings, leScanCallback)
        }
    }

    // Callback appelÃ© Ã  chaque pÃ©riphÃ©rique trouvÃ©.
    private val leScanCallback: ScanCallback = object : ScanCallback() {
        override fun onScanResult(callbackType: Int, result: ScanResult) {
            super.onScanResult(callbackType, result)

            // C'est ici que nous allons crÃ©er notre Â« device Â» et l'ajouter dans le RecyclerView (Datasource)

            val device = Device(result.device.name, result.device.address, result.device)
            if (!bleDevicesFoundList.contains(device)) {
                bleDevicesFoundList.add(device)
            }
        }
    }

    private fun connectToCurrentDevice() {
        BluetoothLEManager.currentDevice?.let { device ->
            Toast.makeText(this, "Connexion en cours â€¦ $device", Toast.LENGTH_SHORT).show()

            currentBluetoothGatt = device.connectGatt(
                this,
                false,
                BluetoothLEManager.GattCallback(
                    onConnect = {
                        // On indique Ã  l'utilisateur que nous sommes correctement connectÃ©
                        runOnUiThread {
                            // Nous sommes connectÃ© au device, on active les notifications pour Ãªtre notifiÃ© si la LED change d'Ã©tat.

                            // Ã€ IMPLÃ‰MENTER
                            // Vous devez appeler la mÃ©thode qui active les notifications BLE
                            // enableListenBleNotify()

                            // On change la vue Â« pour Ãªtre en mode connectÃ© Â»
                            setUiMode(true)

                            // On sauvegarde dans les Â« LocalPrÃ©fÃ©rence Â» de l'application le nom du dernier prÃ©phÃ©rique
                            // sur lequel nous nous sommes connectÃ©

                            // Ã€ IMPLÃ‰MENTER EN FONCTION DE CE QUE NOUS AVONS DIT ENSEMBLE
                        }
                    },
                    onNotify = {
                        runOnUiThread {
                            // VOUS DEVEZ APPELER ICI LA MÃ‰THODE QUI VA GÃ‰RER LE CHANGEMENT D'Ã‰TAT DE LA LED DANS L'INTERFACE
                            // handleToggleLedNotificationUpdate(it)
                        }
                    },
                    onDisconnect = { runOnUiThread { disconnectFromCurrentDevice() } })
            )
        }
    }

    /**
     * On demande la dÃ©connexion du device
     */
    private fun disconnectFromCurrentDevice() {
        currentBluetoothGatt?.disconnect()
        BluetoothLEManager.currentDevice = null
        setUiMode(false)
    }

    private fun setUiMode(isConnected: Boolean) {
        if (isConnected) {
            // ConnectÃ© Ã  un pÃ©riphÃ©rique
            bleDevicesFoundList.clear()
            Recycler_BLE.visibility = View.GONE
            startScan.visibility = View.GONE
            currentConnexion.visibility = View.VISIBLE
            currentConnexion.text =
                getString(R.string.connected_to, BluetoothLEManager.currentDevice?.name)
            disconnect.visibility = View.VISIBLE
            toggleLed.visibility = View.VISIBLE
        } else {
            // Non connectÃ©, reset de la vue.
            Recycler_BLE.visibility = View.VISIBLE
            startScan.visibility = View.VISIBLE
            //ledStatus.visibility = View.GONE
            currentConnexion.visibility = View.GONE
            disconnect.visibility = View.GONE
            toggleLed.visibility = View.GONE
        }
    }


}

